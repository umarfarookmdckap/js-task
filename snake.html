<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Retro Snake — HTML/CSS/JS</title>

<!-- Retro pixel font (fallback to monospace if offline) -->
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  :root{
    --bg: #071019;
    --panel: #08121a;
    --grid: rgba(255,255,255,0.03);
    --snake: #7ef9a2;
    --apple: #ff6b6b;
    --text: #9fe7ff;
    --accent: #ffd166;
    --crt: rgba(255,255,255,0.03);
  }

  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#03060a);font-family:'Press Start 2P', monospace;color:var(--text);-webkit-font-smoothing:antialiased}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:28px;box-sizing:border-box;gap:28px}
  .card{
    width:760px;max-width:96vw;background:linear-gradient(180deg,var(--panel),#031018);border-radius:12px;padding:18px;box-shadow:0 20px 60px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    display:flex;gap:18px;align-items:center;justify-content:center;
  }

  /* game area */
  .game-area{
    background:linear-gradient(180deg,#0b1b24 0%, #071018 100%);
    padding:12px;border-radius:8px;position:relative;
    display:flex;flex-direction:column;align-items:center;gap:12px;
  }

  /* canvas framed to look retro */
  .screen-wrap{
    background: radial-gradient(1200px 500px at 30% 20%, rgba(255,255,255,0.02), transparent 10%), repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 1px, transparent 2px);
    padding:12px;border-radius:6px;border:2px solid rgba(255,255,255,0.03);box-shadow:0 10px 30px rgba(0,0,0,0.6);
  }

  canvas{
    image-rendering: pixelated; /* crisp pixels */
    display:block;background:linear-gradient(180deg,#02223033,#00121a66);
    border-radius:4px;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02), 0 6px 18px rgba(0,0,0,0.8);
  }

  /* CRT scanline overlay */
  .crt {
    pointer-events:none;position:absolute;inset:0;border-radius:8px;mix-blend-mode:overlay;opacity:0.08;background-image:linear-gradient(transparent 50%, rgba(0,0,0,0.12) 51%);background-size:100% 4px;
  }

  /* HUD */
  .hud{display:flex;flex-direction:column;gap:10px;align-items:flex-start}
  .score-box{display:flex;gap:12px;align-items:center}
  .score, .hi{background:linear-gradient(180deg,#021a22,#03161b);padding:8px 12px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-size:12px;color:var(--text)}
  .controls{font-size:11px;color:#cfeefc;opacity:0.9;max-width:200px}
  .title{font-size:12px;color:var(--accent);margin:0 0 6px 0}

  .buttons{display:flex;gap:8px;margin-top:6px}
  .btn{background:#0b2a33;border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:6px;color:var(--text);font-size:11px;cursor:pointer}
  .btn.secondary{background:#062025}
  .small{font-size:10px;opacity:0.85}

  /* responsive */
  @media (max-width:760px){
    .card{flex-direction:column;padding:12px;width:96vw}
    .hud{flex-direction:row;gap:10px;align-items:center}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="game-area">
        <div class="title">RETRO SNAKE</div>
        <div class="screen-wrap" style="position:relative">
          <!-- Canvas: we'll use a small logical grid and scale up for pixel look -->
          <canvas id="screen" width="320" height="320"></canvas>
          <div class="crt" style="display:block"></div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;">
          <div class="score-box"><div class="score">SCORE: <span id="score">0</span></div></div>
          <div class="score-box"><div class="hi">HIGH: <span id="high">0</span></div></div>
          <div style="margin-left:12px" class="small">Speed increases with length • Press <strong>Space</strong> to Pause/Start</div>
        </div>
      </div>

      <div class="hud" style="margin-left:12px">
        <div>
          <div style="font-size:11px;color:var(--accent);margin-bottom:8px">CONTROLS</div>
          <div class="controls">
            <div>← → ↑ ↓ <span class="small">or</span> WASD</div>
            <div class="small">Space to Pause / R to Restart</div>
          </div>

          <div class="buttons" style="margin-top:12px">
            <button id="btnStart" class="btn">Start</button>
            <button id="btnEasy" class="btn secondary">Easy</button>
            <button id="btnMed" class="btn secondary">Medium</button>
            <button id="btnHard" class="btn secondary">Hard</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Retro Snake — single file game
   logic: grid-based snake using requestAnimationFrame with fixed timestep loops,
   controls: arrows + WASD, space pause, R restart.
*/

// Canvas setup: use a small logical grid (20x20) then scale to canvas size for pixel look
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');

const LOGICAL_SIZE = 20;            // grid cells per side
const CANVAS_PIXELS = canvas.width; // 320
const CELL = CANVAS_PIXELS / LOGICAL_SIZE; // 16 px per cell

// HUD elements
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const btnStart = document.getElementById('btnStart');
const btnEasy = document.getElementById('btnEasy');
const btnMed = document.getElementById('btnMed');
const btnHard = document.getElementById('btnHard');

// Game variables
let snake = [];
let dir = {x:1, y:0}; // starting moving right
let nextDir = dir;
let apple = {x:0,y:0};
let score = 0;
let high = parseInt(localStorage.getItem('retroSnakeHigh') || '0', 10);
highEl.textContent = high;
let running = false;
let gameOver = false;

// Timing
let baseSpeed = 6; // ticks per second (difficulty modifies)
let speed = baseSpeed;
let tickInterval = 1000 / speed;
let accumulator = 0;
let lastTime = 0;

// Difficulty buttons
btnEasy.addEventListener('click', ()=>{ baseSpeed = 5; restart();});
btnMed.addEventListener('click', ()=>{ baseSpeed = 8; restart();});
btnHard.addEventListener('click', ()=>{ baseSpeed = 12; restart();});
btnStart.addEventListener('click', ()=>{ toggleRunning(); });

// init
function resetState(){
  snake = [
    {x:8, y:10},
    {x:7, y:10},
    {x:6, y:10}
  ];
  dir = {x:1,y:0};
  nextDir = {x:1,y:0};
  placeApple();
  score = 0;
  speed = baseSpeed;
  tickInterval = 1000 / speed;
  accumulator = 0;
  gameOver = false;
  scoreEl.textContent = score;
}

function placeApple(){
  // choose random empty cell
  let valid = false;
  while(!valid){
    apple.x = Math.floor(Math.random()*LOGICAL_SIZE);
    apple.y = Math.floor(Math.random()*LOGICAL_SIZE);
    valid = !snake.some(s => s.x === apple.x && s.y === apple.y);
  }
}

// draw functions
function clearScreen(){
  // draw retro background
  ctx.fillStyle = '#00141a';
  ctx.fillRect(0,0,CANVAS_PIXELS,CANVAS_PIXELS);

  // subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let i=0;i<=LOGICAL_SIZE;i++){
    // vertical
    ctx.beginPath();
    ctx.moveTo(i*CELL,0);
    ctx.lineTo(i*CELL,CANVAS_PIXELS);
    ctx.stroke();
    ctx.closePath();
    // horizontal
    ctx.beginPath();
    ctx.moveTo(0,i*CELL);
    ctx.lineTo(CANVAS_PIXELS,i*CELL);
    ctx.stroke();
    ctx.closePath();
  }
}

function drawCell(x,y,color){
  ctx.fillStyle = color;
  ctx.fillRect(x*CELL + 1, y*CELL + 1, CELL - 2, CELL - 2);
  // small inner highlight for retro look
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  ctx.fillRect(x*CELL + 2, y*CELL + 2, CELL - 4, 3);
}

function draw(){
  clearScreen();

  // draw apple
  drawCell(apple.x, apple.y, '#ff6b6b');

  // draw snake body
  for(let i=0;i<snake.length;i++){
    const s = snake[i];
    const t = i === 0 ? '#b9ffcf' : (i % 2 === 0 ? '#7ef9a2' : '#4fe085');
    drawCell(s.x, s.y, t);
  }

  // center overlay text when paused or game over
  if(!running && !gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(32,120,CANVAS_PIXELS-64,80);
    ctx.fillStyle = '#9fe7ff';
    ctx.font = '10px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('PRESS SPACE TO START', CANVAS_PIXELS/2, 160);
  }

  if(gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(22,100, CANVAS_PIXELS-44,120);
    ctx.fillStyle = '#ff9b9b';
    ctx.font = '12px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', CANVAS_PIXELS/2, 140);
    ctx.fillStyle = '#9fe7ff';
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.fillText('PRESS R TO RESTART', CANVAS_PIXELS/2, 170);
  }
}

// game logic tick
function tick(){
  // apply direction
  dir = nextDir;

  // compute new head
  const head = { x: (snake[0].x + dir.x + LOGICAL_SIZE) % LOGICAL_SIZE,
                 y: (snake[0].y + dir.y + LOGICAL_SIZE) % LOGICAL_SIZE };

  // check self collision
  if(snake.some((seg)=> seg.x === head.x && seg.y === head.y)){
    // hit itself -> game over
    running = false;
    gameOver = true;
    updateHighScore();
    return;
  }

  // move snake
  snake.unshift(head);

  // eat apple?
  if(head.x === apple.x && head.y === apple.y){
    score += Math.floor(10 + snake.length/2);
    scoreEl.textContent = score;
    placeApple();

    // increase speed a bit every few apples
    speed = baseSpeed + Math.floor(snake.length / 6);
    tickInterval = 1000 / speed;
  } else {
    // remove tail
    snake.pop();
  }
}

// high score
function updateHighScore(){
  if(score > high){
    high = score;
    localStorage.setItem('retroSnakeHigh', String(high));
    highEl.textContent = high;
  }
}

// input handling
window.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W'){
    if(dir.y !== 1) nextDir = {x:0,y:-1};
  } else if(e.key === 'ArrowDown' || e.key === 's' || e.key === 'S'){
    if(dir.y !== -1) nextDir = {x:0,y:1};
  } else if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){
    if(dir.x !== 1) nextDir = {x:-1,y:0};
  } else if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){
    if(dir.x !== -1) nextDir = {x:1,y:0};
  } else if(e.code === 'Space'){
    // pause/start
    toggleRunning();
  } else if(e.key === 'r' || e.key === 'R'){
    restart();
  }
});

// start/stop toggle
function toggleRunning(){
  if(gameOver){
    restart();
    return;
  }
  running = !running;
  if(running){
    lastTime = performance.now();
    requestAnimationFrame(loop);
  } else {
    // paused
  }
}

// restart
function restart(){
  resetState();
  running = true;
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

// main loop with fixed timestep
function loop(now){
  if(!running && !gameOver){
    draw();
    return;
  }

  if(!running && gameOver){
    draw();
    return;
  }

  const delta = now - lastTime;
  lastTime = now;
  accumulator += delta;

  // process ticks if enough time has passed
  while(accumulator >= tickInterval){
    tick();
    accumulator -= tickInterval;
    if(gameOver) break;
  }

  draw();

  if(!gameOver){
    requestAnimationFrame(loop);
  } else {
    draw();
  }
}

// initial state
resetState();
draw();

// small helper: mobile touch controls (tap left/right/up)
let touchStartX = 0;
canvas.addEventListener('touchstart', (ev)=>{
  const t = ev.touches[0];
  touchStartX = t.clientX;
}, {passive:true});

canvas.addEventListener('touchend', (ev)=>{
  const t = ev.changedTouches[0];
  const dx = t.clientX - touchStartX;
  if(Math.abs(dx) > 20){
    // left/right swipe
    if(dx > 0 && dir.x !== -1) nextDir = {x:1,y:0};
    else if(dx < 0 && dir.x !== 1) nextDir = {x:-1,y:0};
  } else {
    // tap = jump to pause/start
    toggleRunning();
  }
});

// keep canvas sharp on high DPI
function resizeForDPI(){
  const dpr = window.devicePixelRatio || 1;
  canvas.width = CANVAS_PIXELS * dpr;
  canvas.height = CANVAS_PIXELS * dpr;
  canvas.style.width = CANVAS_PIXELS + 'px';
  canvas.style.height = CANVAS_PIXELS + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
resizeForDPI();

// initial animation hint
(function blinkStartBtn(){
  let on = true;
  setInterval(()=>{
    btnStart.style.opacity = on ? '1' : '0.6';
    on = !on;
  }, 700);
})();
</script>
</body>
</html>
